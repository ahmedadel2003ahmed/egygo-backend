# Flutter AI Chatbot Integration Guide

## Overview
This guide details how to integrate the "LocalGuide AI" chatbot into the Flutter mobile application. The chatbot supports hybrid responses (Database FAQ + Gemini AI) and maintains conversation context.

## 1. API Configuration

### Base URL
Assuming your backend is hosted at `https://api.yourdomain.com` (or `http://10.0.2.2:5000` for Android Emulator):
- **Endpoint**: `/api/chat`
- **Method**: `POST`
- **Auth**: Not required (Public access), but you can add Bearer token if utilizing protected context later.

### Headers
```json
{
  "Content-Type": "application/json"
}
```

## 2. Request Structure

The backend expects the current message + the conversation history to maintain context.

### JSON Body
```json
{
  "message": "Can you recommend a hotel in Aswan?",
  "history": [
    {
      "role": "user",
      "content": "Hi there!"
    },
    {
      "role": "model",
      "content": "Hello! I'm LocalGuide AI. How can I help you explore Egypt?"
    }
  ]
}
```

### Flutter Model (Suggestion)
```dart
class ChatMessage {
  final String content;
  final String role; // 'user' or 'model'

  ChatMessage({required this.content, required this.role});

  Map<String, dynamic> toJson() => {
    'role': role,
    'content': content,
  };
}
```

## 3. Response Structure

The backend returns a standardized JSON response indicating source and content.

### JSON Response
```json
{
  "success": true,
  "source": "gemini", 
  "reply": "I recommend the Old Cataract Hotel for a historic luxury experience..."
}
```

| Field | Type | Description |
|-------|------|-------------|
| `success` | Boolean | True if request processed successfully. |
| `source` | String | `'database'` (FAQ Match) or `'gemini'` (AI Generated). |
| `reply` | String | The actual text to display in the UI. |

**Note**: If `source` is `'gemini'`, the `reply` might contain general knowledge or summarized data from the database (like a list of hotels).

### Error Response
If the server fails or AI is unreachable, it returns a friendly fallback message:
```json
{
  "success": false,
  "source": "database",
  "reply": "معلش حصلت مشكلة مؤقتة، ممكن تعيد سؤالك بطريقة تانية؟"
}
```

## 4. Implementation Logic (Flutter)

1.  **State Management**: Maintain a `List<ChatMessage>` in your provider/bloc.
2.  **Sending Message**:
    *   Add user's message to the list immediately (update UI).
    *   Show "Typing..." indicator.
    *   Call `POST /api/chat` with `message` and the *current* `history` list.
3.  **Receiving Response**:
    *   Remove "Typing..." indicator.
    *   Add `response.data['reply']` to the list with `role: 'model'`.
    *   (Optional) If `response.data['source'] == 'database'`, you might want to show a "Verified Answer" badge or icon.

## 5. Mobile UX Best Practices

*   **Typing Indicator**: The AI call may take 1-3 seconds. Always show a skeleton loader or "LocalGuide is typing..." animation.
*   **Auto-Scroll**: scroll to the bottom of the `ListView` when a new message arrives.
*   **Markdown Support**: The AI might return bold text or bullet points. Use a package like `flutter_markdown` to render the `reply`.
    ```yaml
    dependencies:
      flutter_markdown: ^0.6.14
    ```
*   **History Limit**: To save bandwidth, you might want to only send the last 10-20 messages in the `history` array.

## 6. Example Service Code (Dart)

```dart
Future<void> sendMessage(String text, List<ChatMessage> history) async {
  final url = Uri.parse('$baseUrl/api/chat');
  
  try {
    final response = await http.post(
      url,
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({
        'message': text,
        'history': history.map((e) => e.toJson()).toList(),
      }),
    );

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      // specific logic based on data['source'] if needed
      final reply = data['reply'];
      // Update UI with reply...
    } else {
      // Handle error
    }
  } catch (e) {
    print('Error sending message: $e');
  }
}
```
